"""
Ð˜Ð½Ñ‚ÐµÐ»Ð»ÐµÐºÑ‚ÑƒÐ°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¿Ñ€Ð¾Ñ†ÐµÑÑÐ¾Ñ€ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð² Ð´Ð»Ñ LLM
Ð ÐµÐ°Ð»Ð¸Ð·ÑƒÐµÑ‚ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð½Ð¾-Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾Ðµ Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð¸Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð², Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹ Ð¿Ð¾Ð´Ð±Ð¾Ñ€ Ð°Ð»ÑŒÑ‚ÐµÑ€Ð½Ð°Ñ‚Ð¸Ð²Ð½Ñ‹Ñ… Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð²
Ð¸ ÑÐ²ÑÐ·Ñ‹Ð²Ð°Ð½Ð¸Ðµ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð² Ñ€Ð°Ð·Ð½Ñ‹Ñ… Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð².
"""

import json
import logging
import re
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)

class ToolExecutionStatus(Enum):
    """Ð¡Ñ‚Ð°Ñ‚ÑƒÑÑ‹ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°"""
    SUCCESS = "success"
    MISSING_PARAMS = "missing_params"
    INVALID_PARAMS = "invalid_params"
    TOOL_ERROR = "tool_error"
    FALLBACK_NEEDED = "fallback_needed"

@dataclass
class ToolExecutionResult:
    """Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°"""
    status: ToolExecutionStatus
    result: Any = None
    error: str = None
    missing_params: List[str] = None
    suggested_fallback: str = None

@dataclass
class ContextParameter:
    """ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€, Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð½Ñ‹Ð¹ Ð¸Ð· ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð°"""
    name: str
    value: Any
    source: str  # "current_message", "chat_history", "user_context"
    confidence: float  # 0.0 - 1.0

class IntelligentToolProcessor:
    """Ð˜Ð½Ñ‚ÐµÐ»Ð»ÐµÐºÑ‚ÑƒÐ°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¿Ñ€Ð¾Ñ†ÐµÑÑÐ¾Ñ€ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð²"""
    
    def __init__(self, llm_client, mcp_client):
        self.llm_client = llm_client
        self.mcp_client = mcp_client
        self.max_fallback_attempts = 3
        self.max_tool_chains = 5
        
    async def process_with_intelligent_tools(self, tools_context: Dict[str, Any]) -> str:
        """
        ÐžÐ±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÑ‚ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ñ Ð¸Ð½Ñ‚ÐµÐ»Ð»ÐµÐºÑ‚ÑƒÐ°Ð»ÑŒÐ½Ñ‹Ð¼ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð²
        
        Args:
            tools_context: ÐšÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ñ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°Ð¼Ð¸ Ð¸ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸ÐµÐ¼
            
        Returns:
            Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸
        """
        try:
            available_tools = tools_context.get('available_tools', [])
            user_message = tools_context.get('user_message', '')
            user_context = tools_context.get('user_context', {})
            chat_history = tools_context.get('chat_history', [])
            
            logger.info(f"ðŸ§  ÐÐ°Ñ‡Ð¸Ð½Ð°ÐµÐ¼ Ð¸Ð½Ñ‚ÐµÐ»Ð»ÐµÐºÑ‚ÑƒÐ°Ð»ÑŒÐ½ÑƒÑŽ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÑƒ: '{user_message[:50]}...'")
            
            # Ð¨Ð°Ð³ 1: Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÐ¼ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¸Ð· ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð° Ð¸ Ð¿Ð¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹, Ð½Ð°Ð¹Ð´ÐµÐ½Ð½Ñ‹Ðµ LLM
            context_params, llm_found_tools = await self._extract_context_parameters(
                user_message, chat_history, user_context, available_tools
            )
            
            # Ð¨Ð°Ð³ 2: ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼ Ð¿Ð¾Ð´Ñ…Ð¾Ð´ÑÑ‰Ð¸Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚
            # Ð•ÑÐ»Ð¸ LLM Ð½Ð°ÑˆÐµÐ» Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹, Ð²Ñ‹Ð±Ð¸Ñ€Ð°ÐµÐ¼ Ð»ÑƒÑ‡ÑˆÐ¸Ð¹ Ð¸Ð· Ð½Ð¸Ñ…
            if llm_found_tools:
                logger.info(f"ðŸŽ¯ LLM Ð¿Ñ€ÐµÐ´Ð»Ð¾Ð¶Ð¸Ð» {len(llm_found_tools)} Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð², Ð²Ñ‹Ð±Ð¸Ñ€Ð°ÐµÐ¼ Ð»ÑƒÑ‡ÑˆÐ¸Ð¹")
                selected_tool = await self._select_best_tool_from_candidates(
                    user_message, llm_found_tools, context_params
                )
            else:
                # Ð•ÑÐ»Ð¸ LLM Ð½Ðµ Ð½Ð°ÑˆÐµÐ» Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ ÑÑ‚Ð°Ñ€ÑƒÑŽ Ð»Ð¾Ð³Ð¸ÐºÑƒ
                logger.info("ðŸ” LLM Ð½Ðµ Ð½Ð°ÑˆÐµÐ» Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ Ð¾Ð±Ñ‰Ð¸Ð¹ Ð¿Ð¾Ð¸ÑÐº")
                selected_tool = await self._select_best_tool(
                    user_message, available_tools, context_params
                )
            
            if not selected_tool:
                return "Ð˜Ð·Ð²Ð¸Ð½Ð¸Ñ‚Ðµ, Ð½Ðµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð½Ð°Ð¹Ñ‚Ð¸ Ð¿Ð¾Ð´Ñ…Ð¾Ð´ÑÑ‰Ð¸Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð´Ð»Ñ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð²Ð°ÑˆÐµÐ³Ð¾ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ°."
            
            # Ð¨Ð°Ð³ 3: Ð’Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÐ¼ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ñ Ð¸Ð½Ñ‚ÐµÐ»Ð»ÐµÐºÑ‚ÑƒÐ°Ð»ÑŒÐ½Ñ‹Ð¼ fallback
            result = await self._execute_tool_with_fallback(
                selected_tool, context_params, user_message, chat_history, user_context
            )
            
            return result
            
        except Exception as e:
            logger.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¸Ð½Ñ‚ÐµÐ»Ð»ÐµÐºÑ‚ÑƒÐ°Ð»ÑŒÐ½Ð¾Ð¹ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸: {e}")
            return f"Ð˜Ð·Ð²Ð¸Ð½Ð¸Ñ‚Ðµ, Ð¿Ñ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ Ð²Ð°ÑˆÐµÐ³Ð¾ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ°: {str(e)}"
    
    async def _extract_context_parameters(
        self, 
        user_message: str, 
        chat_history: List[Dict[str, Any]], 
        user_context: Dict[str, Any],
        available_tools: List[Dict[str, Any]]
    ) -> Tuple[List[ContextParameter], List[Dict[str, Any]]]:
        """
        Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÑ‚ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¸Ð· ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð° (Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐ¼Ñƒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸ÑŽ)
        
        Args:
            user_message: Ð¢ÐµÐºÑƒÑ‰ÐµÐµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
            chat_history: Ð˜ÑÑ‚Ð¾Ñ€Ð¸Ñ Ñ‡Ð°Ñ‚Ð° (Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¾ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¼Ð¸ 2 ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸ÑÐ¼Ð¸)
            user_context: ÐšÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
            available_tools: Ð”Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹
            
        Returns:
            ÐšÐ¾Ñ€Ñ‚ÐµÐ¶: (ÑÐ¿Ð¸ÑÐ¾Ðº Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð½Ñ‹Ñ… Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð², ÑÐ¿Ð¸ÑÐ¾Ðº Ð½Ð°Ð¹Ð´ÐµÐ½Ð½Ñ‹Ñ… Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð²)
        """
        context_params = []
        
        try:
            # ÐžÐ³Ñ€Ð°Ð½Ð¸Ñ‡Ð¸Ð²Ð°ÐµÐ¼ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ñ‡Ð°Ñ‚Ð° Ð´Ð¾ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ñ… 2 ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹
            recent_history = chat_history[-2:] if chat_history else []
            
            # Ð¡Ð¾Ð±Ð¸Ñ€Ð°ÐµÐ¼ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ñ Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚Ð¾Ð¼ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐ¼Ñƒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸ÑŽ
            context_parts = [user_message]  # ÐŸÑ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¼Ñƒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸ÑŽ
            
            # Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ðµ 2 ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð¸Ð· Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ð¸
            for msg in recent_history:
                if msg.get('content'):
                    context_parts.append(msg['content'])
            
            # Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ (ÐµÑÐ»Ð¸ ÐµÑÑ‚ÑŒ)
            if user_context.get('user_additional_context'):
                context_parts.append(user_context['user_additional_context'])
            
            full_context = " ".join(context_parts)
            
            # Ð¤Ð¾Ñ€Ð¼Ð¸Ñ€ÑƒÐµÐ¼ ÑÐ¸ÑÑ‚ÐµÐ¼Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ñ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÐµÐ¹ Ð¾Ð± Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°Ñ…
            # Ð“Ñ€ÑƒÐ¿Ð¿Ð¸Ñ€ÑƒÐµÐ¼ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹ Ð¿Ð¾ ÑÐµÑ€Ð²ÐµÑ€Ð°Ð¼ Ñ ÑƒÐ»ÑƒÑ‡ÑˆÐµÐ½Ð½Ñ‹Ð¼ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ð¾Ð¼ Ð´Ð»Ñ Gemma3:12b
            from collections import defaultdict

            tools_by_server = defaultdict(list)
            for tool in available_tools:
                server = tool.get('server', 'Ð‘ÐµÐ· ÑÐµÑ€Ð²ÐµÑ€Ð°')
                tool_name = tool.get('name', '')
                tool_description = tool.get('description', '')
                # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð²ÑÐµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹, Ð° Ð½Ðµ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ
                all_params = list(tool.get('inputSchema', {}).get('properties', {}).keys())
                
                # Ð¤Ð¾Ñ€Ð¼Ð¸Ñ€ÑƒÐµÐ¼ ÑÐ¿Ð¸ÑÐ¾Ðº Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ð² Ñ‡Ð¸Ñ‚Ð°ÐµÐ¼Ð¾Ð¼ Ð²Ð¸Ð´Ðµ
                params_list = ', '.join(all_params) if all_params else 'Ð½ÐµÑ‚ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð²'
                
                tool_info = f"- {tool_name}\n  - Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ: {tool_description}\n  - Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹: {params_list}"
                tools_by_server[server].append(tool_info)

            grouped_tools_info = ""
            for server, tools in tools_by_server.items():
                #grouped_tools_info += f"\n### {server} Tools\n"
                grouped_tools_info += "\n".join(tools) + "\n"

            system_message = f"""Ð¢Ñ‹ - ÑÐ¸ÑÑ‚ÐµÐ¼Ð½Ñ‹Ð¹ Ð¿Ð°Ñ€ÑÐµÑ€ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð². Ð¢Ð²Ð¾Ñ ÐµÐ´Ð¸Ð½ÑÑ‚Ð²ÐµÐ½Ð½Ð°Ñ Ð·Ð°Ð´Ð°Ñ‡Ð° - Ñ‚Ð¾Ñ‡Ð½Ð¾ Ð¸Ð·Ð²Ð»ÐµÑ‡ÑŒ Ð’Ð¡Ð• Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¸Ð· Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð´Ð»Ñ ÐšÐÐ–Ð”ÐžÐ“Ðž ÑƒÐ¿Ð¾Ð¼ÑÐ½ÑƒÑ‚Ð¾Ð³Ð¾ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð° Ð¸ Ð¿Ñ€ÐµÐ´ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ Ð¸Ñ… Ð² ÑÑ‚Ñ€Ð¾Ð³Ð¾ Ð·Ð°Ð´Ð°Ð½Ð½Ð¾Ð¼ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ðµ.

Ð–Ð•Ð¡Ð¢ÐšÐ˜Ð• ÐŸÐ ÐÐ’Ð˜Ð›Ð:
1. Ð˜Ð¡ÐŸÐžÐ›Ð¬Ð—Ð£Ð™ Ð¢ÐžÐ§ÐÐ«Ð• ÐÐÐ—Ð’ÐÐÐ˜Ð¯ Ð˜ÐÐ¡Ð¢Ð Ð£ÐœÐ•ÐÐ¢ÐžÐ’, ÐºÐ°Ðº Ð² Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ðµ Ð½Ð¸Ð¶Ðµ. ÐÐ• Ð¸Ð·Ð¼ÐµÐ½ÑÐ¹ Ð¸ Ð½Ðµ Ñ‚Ð²Ð¾Ñ€Ñ‡ÐµÑÐºÐ¸ Ð¿ÐµÑ€ÐµÐ¸Ð¼ÐµÐ½Ð¾Ð²Ñ‹Ð²Ð°Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹.
2. Ð˜Ð—Ð’Ð›Ð•ÐšÐ˜ Ð’Ð¡Ð• Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ (ÐºÐ°Ðº Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ, Ñ‚Ð°Ðº Ð¸ Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ðµ), Ð´Ð°Ð¶Ðµ ÐµÑÐ»Ð¸ Ð¾Ð½Ð¸ Ð½ÐµÑÐ²Ð½Ð¾ ÑƒÐ¿Ð¾Ð¼ÑÐ½ÑƒÑ‚Ñ‹ Ð² Ð·Ð°Ð¿Ñ€Ð¾ÑÐµ.
3. Ð”Ð›Ð¯ ÐšÐÐ–Ð”ÐžÐ“Ðž Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð° Ð¿Ñ€Ð¾Ð´ÑƒÐ±Ð»Ð¸Ñ€ÑƒÐ¹ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¿Ð¾Ð´ Ð¸Ð¼ÐµÐ½ÐµÐ¼, ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ðµ ÐžÐ–Ð˜Ð”ÐÐ•Ð¢ ÑÑ‚Ð¾Ñ‚ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ñ‹Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚.
4. Ð•ÑÐ»Ð¸ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€ Ð´Ð»Ñ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð° Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½ ÑÐ²Ð½Ð¾, Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹ Ð²Ñ‹Ð²ÐµÑÑ‚Ð¸ ÐµÐ³Ð¾ Ð¸Ð· ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð° Ð¸Ð»Ð¸ ÑƒÐºÐ°Ð¶Ð¸ `null`.
5. Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚ Ð²Ñ‹Ð²Ð¾Ð´Ð° Ð¢ÐžÐ›Ð¬ÐšÐž JSON, ÐºÐ°Ðº Ð² Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ðµ.
6. Ð’ÐÐ–ÐÐž: Ð˜Ð·Ð²Ð»ÐµÐºÐ°Ð¹ Ð’Ð¡Ð• Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¸Ð· ÑÐ¿Ð¸ÑÐºÐ°, Ð½Ðµ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ!

Ð¡ÐŸÐ˜Ð¡ÐžÐš Ð˜ÐÐ¡Ð¢Ð Ð£ÐœÐ•ÐÐ¢ÐžÐ’ Ð˜ Ð˜Ð¥ Ð’Ð¡Ð•Ð¥ ÐŸÐÐ ÐÐœÐ•Ð¢Ð ÐžÐ’:
{grouped_tools_info}

Ð¤ÐžÐ ÐœÐÐ¢ ÐžÐ¢Ð’Ð•Ð¢Ð:
{{
    "parameters": {{
        "Ð¸Ð¼Ñ_Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°": "Ð½Ð°Ð¹Ð´ÐµÐ½Ð½Ð¾Ðµ_Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ"
    }},
    "found_tools": ["Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ_Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°_1", "Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ_Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°_2"]
}}"""

            messages = [
                {"role": "system", "content": system_message},
                {"role": "user", "content": user_message}
            ]
            
            response = await self.llm_client.llm_provider.generate_response(messages)
            
            # ÐŸÐ°Ñ€ÑÐ¸Ð¼ Ð¾Ñ‚Ð²ÐµÑ‚ Ñ ÑƒÐ»ÑƒÑ‡ÑˆÐµÐ½Ð½Ð¾Ð¹ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¾Ð¹ Ð´Ð»Ñ Gemma3:12b
            try:
                # ÐžÑ‡Ð¸Ñ‰Ð°ÐµÐ¼ Ð¾Ñ‚Ð²ÐµÑ‚ Ð¾Ñ‚ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ñ‹Ñ… Ð»Ð¸ÑˆÐ½Ð¸Ñ… ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²
                cleaned_response = response.strip()
                
                # Ð˜Ñ‰ÐµÐ¼ JSON Ð±Ð»Ð¾Ðº Ð² Ð¾Ñ‚Ð²ÐµÑ‚Ðµ
                json_start = cleaned_response.find('{')
                json_end = cleaned_response.rfind('}') + 1
                
                if json_start != -1 and json_end > json_start:
                    json_str = cleaned_response[json_start:json_end]
                    extracted_data = json.loads(json_str)
                    
                    # ÐžÐ±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÐ¼ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¸Ð· Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ð°
                    parameters = extracted_data.get('parameters', {})
                    found_tools = extracted_data.get('found_tools', [])
                    
                    logger.info(f"ðŸ” ÐÐ°Ð¹Ð´ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹: {list(parameters.keys()) if isinstance(parameters, dict) else parameters}")
                    logger.info(f"ðŸ› ï¸ ÐŸÐ¾Ð´Ñ…Ð¾Ð´ÑÑ‰Ð¸Ðµ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹: {found_tools}")

                    # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð’Ð¡Ð• Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¸Ð· Ð²ÑÐµÑ… Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð² (Ð½Ðµ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ)
                    all_valid_params = set()
                    tool_all_param_map = {}
                    tool_required_param_map = {}
                    
                    for tool in available_tools:
                        tool_name = tool.get('name', '')
                        input_schema = tool.get('inputSchema', {})
                        properties = input_schema.get('properties', {})
                        required_params = input_schema.get('required', [])
                        
                        # Ð¡Ð¾Ð±Ð¸Ñ€Ð°ÐµÐ¼ Ð’Ð¡Ð• Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°
                        all_tool_params = set(properties.keys())
                        all_valid_params.update(all_tool_params)
                        tool_all_param_map[tool_name] = all_tool_params
                        tool_required_param_map[tool_name] = set(required_params)

                    # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ñ‹ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð²
                    if isinstance(parameters, dict):
                        # Ð•ÑÐ»Ð¸ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð°: {param: value, ...} (ÑÑ‚Ð°Ñ€Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚)
                        # Ð¸Ð»Ð¸ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð°: {tool_name: {param: value, ...}, ...} (Ð½Ð¾Ð²Ñ‹Ð¹ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð½Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚)
                        is_nested = False
                        # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, ÐµÑÐ»Ð¸ ÐºÐ»ÑŽÑ‡Ð¸ parameters ÑÐ¾Ð²Ð¿Ð°Ð´Ð°ÑŽÑ‚ Ñ Ð¸Ð¼ÐµÐ½Ð°Ð¼Ð¸ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð²
                        if all(isinstance(k, str) and k in tool_required_param_map for k in parameters.keys()):
                            # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, Ñ‡Ñ‚Ð¾ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ - dict (Ñ‚.Ðµ. Ð²Ð»Ð¾Ð¶ÐµÐ½Ð½Ð°Ñ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð°)
                            if all(isinstance(v, dict) for v in parameters.values()):
                                is_nested = True

                        if is_nested:
                            # ÐÐ¾Ð²Ñ‹Ð¹ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð½Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚: {tool_name: {param: value, ...}, ...}
                            for tool_name, param_dict in parameters.items():
                                all_tool_params = tool_all_param_map.get(tool_name, set())
                                required_params = tool_required_param_map.get(tool_name, set())
                                
                                for param_name, param_value in param_dict.items():
                                    if param_name in all_tool_params:
                                        # ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼ Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚: Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¿Ð¾Ð»ÑƒÑ‡Ð°ÑŽÑ‚ Ð±Ð¾Ð»ÐµÐµ Ð²Ñ‹ÑÐ¾ÐºÐ¸Ð¹ confidence
                                        confidence = 0.95 if param_name in required_params else 0.85
                                        
                                        context_params.append(ContextParameter(
                                            name=param_name,
                                            value=str(param_value),
                                            source='llm_extraction',
                                            confidence=confidence
                                        ))
                                        param_type = "Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹" if param_name in required_params else "Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹"
                                        logger.info(f"âœ… [{tool_name}] {param_type} Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€ '{param_name}' = '{param_value}' Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½")
                                    else:
                                        logger.warning(f"âš ï¸ [{tool_name}] LLM Ð²Ñ‹Ð´ÑƒÐ¼Ð°Ð» Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€ '{param_name}' - Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½ Ð² Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ðµ")
                        else:
                            # Ð¡Ñ‚Ð°Ñ€Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚: {param: value, ...}
                            for param_name, param_value in parameters.items():
                                if param_name in all_valid_params:
                                    # ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼, Ðº ÐºÐ°ÐºÐ¾Ð¼Ñƒ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñƒ Ð¿Ñ€Ð¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð¸Ñ‚ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€
                                    param_tools = [tool for tool, params in tool_all_param_map.items() if param_name in params]
                                    is_required = any(param_name in tool_required_param_map.get(tool, set()) for tool in param_tools)
                                    
                                    # ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼ confidence Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ñ‚Ð¾Ð³Ð¾, Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ð»Ð¸ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€
                                    confidence = 0.95 if is_required else 0.85
                                    
                                    context_params.append(ContextParameter(
                                        name=param_name,
                                        value=str(param_value),
                                        source='llm_extraction',
                                        confidence=confidence
                                    ))
                                    param_type = "Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹" if is_required else "Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹"
                                    tools_str = ", ".join(param_tools) if param_tools else "Ð½ÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ñ‹Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚"
                                    logger.info(f"âœ… {param_type} Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€ '{param_name}' = '{param_value}' Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½ (Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹: {tools_str})")
                                else:
                                    logger.warning(f"âš ï¸ LLM Ð²Ñ‹Ð´ÑƒÐ¼Ð°Ð» Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€ '{param_name}' - Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½ Ð² Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°Ñ…")
                    else:
                        logger.warning("âš ï¸ ÐÐµÐ¾Ð¶Ð¸Ð´Ð°Ð½Ð½Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚ parameters: %s", type(parameters))
                else:
                    logger.warning("âš ï¸ JSON Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½ Ð² Ð¾Ñ‚Ð²ÐµÑ‚Ðµ Gemma3:12b")
                    
            except json.JSONDecodeError as e:
                logger.warning(f"âš ï¸ ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ñ€Ð°ÑÐ¿Ð°Ñ€ÑÐ¸Ñ‚ÑŒ Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¾Ñ‚ Gemma3:12b: {e}")
                logger.debug(f"ÐžÑ‚Ð²ÐµÑ‚ Gemma3:12b: {response}")
                
                # ÐŸÐ¾Ð¿Ñ‹Ñ‚ÐºÐ° Ð¸Ð·Ð²Ð»ÐµÑ‡ÑŒ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¸Ð· Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ð¾Ð³Ð¾ Ð¾Ñ‚Ð²ÐµÑ‚Ð°
                if 'tool' in response.lower() or 'parameter' in response.lower():
                    # ÐŸÑ€Ð¾ÑÑ‚Ð¾Ðµ Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð¸Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ð¸Ð· Ñ‚ÐµÐºÑÑ‚Ð°
                    lines = response.split('\n')
                    for line in lines:
                        if ':' in line and any(keyword in line.lower() for keyword in ['project', 'task', 'user', 'file', 'search']):
                            parts = line.split(':', 1)
                            if len(parts) == 2:
                                param_name = parts[0].strip().lower().replace(' ', '_')
                                param_value = parts[1].strip()
                                if param_value and len(param_value) > 1:
                                    context_params.append(ContextParameter(
                                        name=param_name,
                                        value=param_value,
                                        source='text_extraction',
                                        confidence=0.6
                                    ))
            
            # Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð¸Ð·Ð²Ð»ÐµÐºÐ°ÐµÐ¼ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ñ€ÐµÐ³ÑƒÐ»ÑÑ€Ð½Ñ‹Ñ… Ð²Ñ‹Ñ€Ð°Ð¶ÐµÐ½Ð¸Ð¹
            #regex_params = self._extract_params_with_regex(full_context)
            #context_params.extend(regex_params)
            
            # Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð°Ñ Ð»Ð¾Ð³Ð¸ÐºÐ°: ÐµÑÐ»Ð¸ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ‹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹, Ð½Ð¾ Ð½Ðµ Ð²ÑÐµ Ð¸Ñ… Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ñ‹,
            # Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐµÐ¼ Ð¸Ð·Ð²Ð»ÐµÑ‡ÑŒ Ð½ÐµÐ´Ð¾ÑÑ‚Ð°ÑŽÑ‰Ð¸Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¸Ð· ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð°
            if found_tools and isinstance(parameters, dict):
                self._extract_missing_optional_params(
                    found_tools, parameters, tool_all_param_map, tool_required_param_map, 
                    full_context, context_params
                )
            
            logger.info(f"âœ… Ð˜Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð¾ {len(context_params)} Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ð¸Ð· ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð°")
            
            # ÐÐ°Ñ…Ð¾Ð´Ð¸Ð¼ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð±Ñ‹Ð»Ð¸ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ‹ LLM
            found_tools_objects = []
            if found_tools:
                for tool_name in found_tools:
                    for tool in available_tools:
                        if tool.get('name') == tool_name:
                            found_tools_objects.append(tool)
                            break
                
                logger.info(f"ðŸ› ï¸ LLM Ð½Ð°ÑˆÐµÐ» Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹: {[t.get('name') for t in found_tools_objects]}")
            
            return context_params, found_tools_objects
            
        except Exception as e:
            logger.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð¸Ñ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð²: {e}")
            return [], []
            
    def _extract_missing_optional_params(
        self, 
        found_tools: List[str], 
        extracted_params: Dict[str, Any], 
        tool_all_param_map: Dict[str, set],
        tool_required_param_map: Dict[str, set],
        context: str,
        context_params: List[ContextParameter]
    ):
        """
        Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÑ‚ Ð½ÐµÐ´Ð¾ÑÑ‚Ð°ÑŽÑ‰Ð¸Ðµ Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¸Ð· ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð°
        
        Args:
            found_tools: Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð½Ð°Ð¹Ð´ÐµÐ½Ð½Ñ‹Ñ… Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð²
            extracted_params: Ð£Ð¶Ðµ Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹
            tool_all_param_map: ÐšÐ°Ñ€Ñ‚Ð° Ð²ÑÐµÑ… Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ð¿Ð¾ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°Ð¼
            tool_required_param_map: ÐšÐ°Ñ€Ñ‚Ð° Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ñ… Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ð¿Ð¾ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°Ð¼
            context: ÐšÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ð´Ð»Ñ Ð¿Ð¾Ð¸ÑÐºÐ°
            context_params: Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ð´Ð»Ñ Ð´Ð¾Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ
        """
        try:
            # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ ÑƒÐ¶Ðµ Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð½Ñ‹Ðµ Ð¸Ð¼ÐµÐ½Ð° Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð²
            extracted_param_names = set()
            for param in context_params:
                extracted_param_names.add(param.name)
            
            # Ð”Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ð½Ð°Ð¹Ð´ÐµÐ½Ð½Ð¾Ð³Ð¾ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð° Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½ÐµÐ´Ð¾ÑÑ‚Ð°ÑŽÑ‰Ð¸Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹
            for tool_name in found_tools:
                all_tool_params = tool_all_param_map.get(tool_name, set())
                required_params = tool_required_param_map.get(tool_name, set())
                
                # ÐÐ°Ñ…Ð¾Ð´Ð¸Ð¼ Ð½ÐµÐ´Ð¾ÑÑ‚Ð°ÑŽÑ‰Ð¸Ðµ Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹
                missing_optional = all_tool_params - extracted_param_names - required_params
                
                if missing_optional:
                    logger.info(f"ðŸ” [{tool_name}] Ð˜Ñ‰ÐµÐ¼ Ð½ÐµÐ´Ð¾ÑÑ‚Ð°ÑŽÑ‰Ð¸Ðµ Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹: {missing_optional}")
                    
                    # ÐŸÑ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð¸Ð·Ð²Ð»ÐµÑ‡ÑŒ Ð½ÐµÐ´Ð¾ÑÑ‚Ð°ÑŽÑ‰Ð¸Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¸Ð· ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð°
                    for param_name in missing_optional:
                        # ÐŸÑ€Ð¾ÑÑ‚Ð¾Ð¹ Ð¿Ð¾Ð¸ÑÐº Ð¿Ð¾ ÐºÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ð¼ ÑÐ»Ð¾Ð²Ð°Ð¼ Ð² ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ðµ
                        param_value = self._extract_param_from_context(param_name, context)
                        if param_value:
                            context_params.append(ContextParameter(
                                name=param_name,
                                value=param_value,
                                source='context_inference',
                                confidence=0.7
                            ))
                            logger.info(f"âœ… [{tool_name}] ÐžÐ¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€ '{param_name}' = '{param_value}' Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½ Ð¸Ð· ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð°")
                        
        except Exception as e:
            logger.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð¸Ñ Ð½ÐµÐ´Ð¾ÑÑ‚Ð°ÑŽÑ‰Ð¸Ñ… Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð²: {e}")
    
    def _extract_param_from_context(self, param_name: str, context: str) -> Optional[str]:
        """
        Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÑ‚ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð° Ð¸Ð· ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð° Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ ÐµÐ³Ð¾ Ð¸Ð¼ÐµÐ½Ð¸
        
        Args:
            param_name: Ð˜Ð¼Ñ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°
            context: ÐšÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ð´Ð»Ñ Ð¿Ð¾Ð¸ÑÐºÐ°
            
        Returns:
            ÐÐ°Ð¹Ð´ÐµÐ½Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð¸Ð»Ð¸ None
        """
        try:
            context_lower = context.lower()
            param_lower = param_name.lower()
            
            # ÐŸÑ€Ð¾ÑÑ‚Ñ‹Ðµ Ð¿Ñ€Ð°Ð²Ð¸Ð»Ð° Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð¸Ñ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð¸Ð¼ÐµÐ½Ð¸ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°
            if 'query' in param_lower or 'search' in param_lower:
                # Ð”Ð»Ñ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ð¿Ð¾Ð¸ÑÐºÐ° Ð¸Ñ‰ÐµÐ¼ ÐºÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ðµ ÑÐ»Ð¾Ð²Ð°
                words = context.split()
                if len(words) > 2:
                    # Ð‘ÐµÑ€ÐµÐ¼ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ ÑÐ»Ð¾Ð² ÐºÐ°Ðº Ð¿Ð¾Ð¸ÑÐºÐ¾Ð²Ñ‹Ð¹ Ð·Ð°Ð¿Ñ€Ð¾Ñ
                    return ' '.join(words[:3])
                    
            elif 'limit' in param_lower or 'count' in param_lower:
                # Ð”Ð»Ñ Ð»Ð¸Ð¼Ð¸Ñ‚Ð¾Ð² Ð¸Ñ‰ÐµÐ¼ Ñ‡Ð¸ÑÐ»Ð°
                import re
                numbers = re.findall(r'\b\d+\b', context)
                if numbers:
                    return numbers[0]
                    
            elif 'sort' in param_lower or 'order' in param_lower:
                # Ð”Ð»Ñ ÑÐ¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²ÐºÐ¸ Ð¸Ñ‰ÐµÐ¼ ÐºÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ðµ ÑÐ»Ð¾Ð²Ð°
                if 'asc' in context_lower or 'Ð²Ð¾Ð·Ñ€Ð°ÑÑ‚Ð°' in context_lower:
                    return 'asc'
                elif 'desc' in context_lower or 'ÑƒÐ±Ñ‹Ð²Ð°' in context_lower:
                    return 'desc'
                    
            elif 'filter' in param_lower:
                # Ð”Ð»Ñ Ñ„Ð¸Ð»ÑŒÑ‚Ñ€Ð¾Ð² Ð¿Ñ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð½Ð°Ð¹Ñ‚Ð¸ ÑƒÑÐ»Ð¾Ð²Ð¸Ñ
                if 'active' in context_lower or 'Ð°ÐºÑ‚Ð¸Ð²' in context_lower:
                    return 'active'
                elif 'inactive' in context_lower or 'Ð½ÐµÐ°ÐºÑ‚Ð¸Ð²' in context_lower:
                    return 'inactive'
                    
            return None
            
        except Exception as e:
            logger.debug(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð¸Ñ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð° {param_name}: {e}")
            return None
    
    def _extract_params_with_regex(self, text: str) -> List[ContextParameter]:
        """Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÑ‚ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ñ€ÐµÐ³ÑƒÐ»ÑÑ€Ð½Ñ‹Ñ… Ð²Ñ‹Ñ€Ð°Ð¶ÐµÐ½Ð¸Ð¹"""
        params = []
        
        # ÐŸÐ°Ñ‚Ñ‚ÐµÑ€Ð½Ñ‹ Ð´Ð»Ñ Ñ€Ð°Ð·Ð»Ð¸Ñ‡Ð½Ñ‹Ñ… Ñ‚Ð¸Ð¿Ð¾Ð² Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² (Ð¸Ñ‰ÐµÐ¼ Ð² ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ðµ, Ð½Ðµ Ð² ÐºÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ñ… Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸ÑÑ…)
        patterns = {
            'project_id': r'(?:Ð¿Ñ€Ð¾ÐµÐºÑ‚|project)[\s:]*([A-Z][A-Z0-9-]+)',
            'task_id': r'(?:Ð·Ð°Ð´Ð°Ñ‡Ð°|task)[\s:]*([A-Z][A-Z0-9-]+)',
            'commit_hash': r'([a-f0-9]{7,40})',
            'file_path': r'(/[^\s]+\.\w+)',
            'username': r'(?:Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ|user)[\s:]*([a-zA-Z0-9_-]+)',
            'keyword': r'(?:Ð½Ð°Ð¹Ð´Ð¸|Ð¿Ð¾Ð¸ÑÐº|search)[\s:]*([^\s]+)',
            'email': r'([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})',
            'url': r'(https?://[^\s]+)',
            'version': r'v?(\d+\.\d+(?:\.\d+)?)',
            'number': r'\b(\d+)\b',
        }
        
        # Ð˜ÑÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ ÐºÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ðµ ÑÐ»Ð¾Ð²Ð° Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ð¹ Ð¸Ð· Ð¿Ð¾Ð¸ÑÐºÐ°
        action_keywords = [
            'ÑÐ¾Ð·Ð´Ð°Ð¹', 'Ð½Ð°Ð¹Ð´Ð¸', 'Ð¿Ð¾ÐºÐ°Ð¶Ð¸', 'Ð¿Ð¾Ð»ÑƒÑ‡Ð¸', 'Ð¾Ð±Ð½Ð¾Ð²Ð¸', 'ÑƒÐ´Ð°Ð»Ð¸', 'Ð´Ð¾Ð±Ð°Ð²ÑŒ',
            'create', 'find', 'show', 'get', 'update', 'delete', 'add',
            'Ð¿Ð¾Ð¸ÑÐº', 'ÑÐ¿Ð¸ÑÐ¾Ðº', 'Ð´ÐµÑ‚Ð°Ð»Ð¸', 'Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ'
        ]
        
        for param_name, pattern in patterns.items():
            matches = re.findall(pattern, text, re.IGNORECASE)
            for match in matches:
                # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, Ñ‡Ñ‚Ð¾ Ð½Ð°Ð¹Ð´ÐµÐ½Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð½Ðµ ÑÐ²Ð»ÑÐµÑ‚ÑÑ ÐºÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ð¼ ÑÐ»Ð¾Ð²Ð¾Ð¼ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ
                if not any(keyword.lower() in match.lower() for keyword in action_keywords):
                    params.append(ContextParameter(
                        name=param_name,
                        value=match,
                        source="regex_extraction",
                        confidence=0.8
                    ))
        
        return params
    
    async def _select_best_tool(
        self, 
        user_message: str, 
        available_tools: List[Dict[str, Any]], 
        context_params: List[ContextParameter]
    ) -> Optional[Dict[str, Any]]:
        """
        Ð’Ñ‹Ð±Ð¸Ñ€Ð°ÐµÑ‚ Ð½Ð°Ð¸Ð±Ð¾Ð»ÐµÐµ Ð¿Ð¾Ð´Ñ…Ð¾Ð´ÑÑ‰Ð¸Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ð¸ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ñ
        
        Args:
            user_message: Ð¡Ð¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
            available_tools: Ð”Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹
            context_params: Ð˜Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹
            
        Returns:
            Ð’Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð¸Ð»Ð¸ None
        """
        try:
            # Ð¡Ð½Ð°Ñ‡Ð°Ð»Ð° Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐµÐ¼ Ð½Ð°Ð¹Ñ‚Ð¸ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð¿Ð¾ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°Ð¼
            selected_tool = self._select_tool_by_parameters(available_tools, context_params, user_message)
            if selected_tool:
                logger.info(f"âœ… Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð²Ñ‹Ð±Ñ€Ð°Ð½ Ð¿Ð¾ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°Ð¼: {selected_tool.get('name')}")
                return selected_tool
            
            # Ð•ÑÐ»Ð¸ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½ Ð¿Ð¾ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°Ð¼, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ LLM Ð´Ð»Ñ Ð²Ñ‹Ð±Ð¾Ñ€Ð°
            return await self._select_tool_with_llm(user_message, available_tools, context_params)
            
        except Exception as e:
            logger.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°: {e}")
            return None
            
    async def _select_best_tool_from_candidates(
        self, 
        user_message: str, 
        candidate_tools: List[Dict[str, Any]], 
        context_params: List[ContextParameter]
    ) -> Optional[Dict[str, Any]]:
        """
        Ð’Ñ‹Ð±Ð¸Ñ€Ð°ÐµÑ‚ Ð»ÑƒÑ‡ÑˆÐ¸Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð¸Ð· ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð², Ð¿Ñ€ÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð½Ñ‹Ñ… LLM
        
        Args:
            user_message: Ð¡Ð¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
            candidate_tools: Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹, Ð¿Ñ€ÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð½Ñ‹Ðµ LLM
            context_params: Ð˜Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹
            
        Returns:
            Ð’Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð¸Ð»Ð¸ None
        """
        try:
            if not candidate_tools:
                return None
            
            # Ð•ÑÐ»Ð¸ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¾Ð´Ð¸Ð½ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚, Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ ÐµÐ³Ð¾
            if len(candidate_tools) == 1:
                logger.info(f"âœ… Ð’Ñ‹Ð±Ñ€Ð°Ð½ ÐµÐ´Ð¸Ð½ÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð¾Ñ‚ LLM: {candidate_tools[0].get('name')}")
                return candidate_tools[0]
            
            # Ð•ÑÐ»Ð¸ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð², Ð²Ñ‹Ð±Ð¸Ñ€Ð°ÐµÐ¼ Ð»ÑƒÑ‡ÑˆÐ¸Ð¹ Ð¿Ð¾ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°Ð¼
            logger.info(f"ðŸ” Ð’Ñ‹Ð±Ð¸Ñ€Ð°ÐµÐ¼ Ð»ÑƒÑ‡ÑˆÐ¸Ð¹ Ð¸Ð· {len(candidate_tools)} Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð² Ð¾Ñ‚ LLM")
            
            best_tool = self._select_tool_by_parameters(candidate_tools, context_params, user_message)
            if best_tool:
                logger.info(f"âœ… Ð’Ñ‹Ð±Ñ€Ð°Ð½ Ð»ÑƒÑ‡ÑˆÐ¸Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð¾Ñ‚ LLM: {best_tool.get('name')}")
                return best_tool
            
            # Ð•ÑÐ»Ð¸ Ð½Ðµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð²Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ð¿Ð¾ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°Ð¼, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ LLM Ð´Ð»Ñ Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ð¸Ð· ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð²
            logger.info("ðŸ¤– Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ LLM Ð´Ð»Ñ Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ð¸Ð· ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð²")
            return await self._select_tool_with_llm_from_candidates(user_message, candidate_tools, context_params)
            
        except Exception as e:
            logger.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð° Ð¸Ð· ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð²: {e}")
            return None
    
    async def _select_tool_with_llm_from_candidates(
        self, 
        user_message: str, 
        candidate_tools: List[Dict[str, Any]], 
        context_params: List[ContextParameter]
    ) -> Optional[Dict[str, Any]]:
        """
        Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ LLM Ð´Ð»Ñ Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð° Ð¸Ð· ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð²
        """
        try:
            # Ð¤Ð¾Ñ€Ð¼Ð¸Ñ€ÑƒÐµÐ¼ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾Ð± Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°Ñ…-ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð°Ñ…
            tools_info = []
            for tool in candidate_tools:
                tool_name = tool.get('name', '')
                tool_description = tool.get('description', '')
                input_schema = tool.get('inputSchema', {})
                all_params = list(input_schema.get('properties', {}).keys())
                required_params = input_schema.get('required', [])
                
                params_info = f"Ð²ÑÐµÐ³Ð¾: {len(all_params)}, Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ñ…: {len(required_params)}"
                tools_info.append(f"- {tool_name}: {tool_description} (Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹: {params_info})")
            
            tools_text = "\n".join(tools_info)
            
            # Ð¤Ð¾Ñ€Ð¼Ð¸Ñ€ÑƒÐµÐ¼ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð´Ð»Ñ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ
            params_text = ""
            if context_params:
                params_list = [f"{p.name}={p.value}" for p in context_params]
                params_text = f"ÐÐ°Ð¹Ð´ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹: {', '.join(params_list)}"
            
            system_message = f"""Ð¢Ñ‹ - ÑÐºÑÐ¿ÐµÑ€Ñ‚ Ð¿Ð¾ Ð²Ñ‹Ð±Ð¾Ñ€Ñƒ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð². Ð˜Ð· Ð¿Ñ€ÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð½Ñ‹Ñ… ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð² Ð²Ñ‹Ð±ÐµÑ€Ð¸ Ð»ÑƒÑ‡ÑˆÐ¸Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð´Ð»Ñ Ð·Ð°Ð´Ð°Ñ‡Ð¸ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ.

ÐšÐÐÐ”Ð˜Ð”ÐÐ¢Ð« (Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ LLM ÑƒÐ¶Ðµ Ð²Ñ‹Ð±Ñ€Ð°Ð» ÐºÐ°Ðº Ð¿Ð¾Ð´Ñ…Ð¾Ð´ÑÑ‰Ð¸Ðµ):
{tools_text}

{params_text}

Ð—ÐÐ”ÐÐ§Ð: Ð’Ñ‹Ð±ÐµÑ€Ð¸ ÐžÐ”Ð˜Ð Ð»ÑƒÑ‡ÑˆÐ¸Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð¸Ð· ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð² Ð²Ñ‹ÑˆÐµ.

Ð¤ÐžÐ ÐœÐÐ¢ ÐžÐ¢Ð’Ð•Ð¢Ð (Ñ‚Ð¾Ð»ÑŒÐºÐ¾ JSON):
{{
    "selected_tool": "Ð¸Ð¼Ñ_Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°",
    "reason": "ÐºÑ€Ð°Ñ‚ÐºÐ¾Ðµ_Ð¾Ð±ÑŠÑÑÐ½ÐµÐ½Ð¸Ðµ_Ð¿Ð¾Ñ‡ÐµÐ¼Ñƒ_ÑÑ‚Ð¾Ñ‚_Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚_Ð»ÑƒÑ‡ÑˆÐ¸Ð¹"
}}

Ð’ÐÐ–ÐÐž: ÐžÑ‚Ð²ÐµÑ‡Ð°Ð¹ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð² JSON Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ðµ! Ð’Ñ‹Ð±Ð¸Ñ€Ð°Ð¹ Ð¢ÐžÐ›Ð¬ÐšÐž Ð¸Ð· ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð² Ð²Ñ‹ÑˆÐµ!"""

            messages = [
                {"role": "system", "content": system_message},
                {"role": "user", "content": user_message}
            ]
            
            response = await self.llm_client.llm_provider.generate_response(messages)
            
            # ÐŸÐ°Ñ€ÑÐ¸Ð¼ Ð¾Ñ‚Ð²ÐµÑ‚
            try:
                cleaned_response = response.strip()
                json_start = cleaned_response.find('{')
                json_end = cleaned_response.rfind('}') + 1
                
                if json_start != -1 and json_end > json_start:
                    json_str = cleaned_response[json_start:json_end]
                    selection_data = json.loads(json_str)
                    
                    selected_tool_name = selection_data.get('selected_tool', '')
                    reason = selection_data.get('reason', '')
                    
                    # ÐÐ°Ñ…Ð¾Ð´Ð¸Ð¼ Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ ÑÑ€ÐµÐ´Ð¸ ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð²
                    for tool in candidate_tools:
                        if tool.get('name') == selected_tool_name:
                            logger.info(f"âœ… LLM Ð²Ñ‹Ð±Ñ€Ð°Ð» Ð¸Ð· ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð²: {selected_tool_name} (Ð¿Ñ€Ð¸Ñ‡Ð¸Ð½Ð°: {reason})")
                            return tool
                    
                    logger.warning(f"âš ï¸ LLM Ð²Ñ‹Ð±Ñ€Ð°Ð» Ð½ÐµÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð¸Ð· ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð²: {selected_tool_name}")
                    # Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ð¿ÐµÑ€Ð²Ñ‹Ð¹ ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚ ÐºÐ°Ðº fallback
                    return candidate_tools[0]
                else:
                    logger.warning("âš ï¸ JSON Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½ Ð² Ð¾Ñ‚Ð²ÐµÑ‚Ðµ LLM Ð¿Ñ€Ð¸ Ð²Ñ‹Ð±Ð¾Ñ€Ðµ Ð¸Ð· ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð²")
                    return candidate_tools[0]
                    
            except json.JSONDecodeError as e:
                logger.warning(f"âš ï¸ ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ñ€Ð°ÑÐ¿Ð°Ñ€ÑÐ¸Ñ‚ÑŒ Ð²Ñ‹Ð±Ð¾Ñ€ Ð¸Ð· ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð²: {e}")
                return candidate_tools[0]
                
        except Exception as e:
            logger.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð° Ñ‡ÐµÑ€ÐµÐ· LLM Ð¸Ð· ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð²: {e}")
            return candidate_tools[0] if candidate_tools else None
    
    def _select_tool_by_parameters(
        self, 
        available_tools: List[Dict[str, Any]], 
        context_params: List[ContextParameter],
        user_message: str
    ) -> Optional[Dict[str, Any]]:
        """
        Ð’Ñ‹Ð±Ð¸Ñ€Ð°ÐµÑ‚ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð½Ñ‹Ñ… Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð²
        """
        if not context_params:
            return None
        
        # Ð¤Ð¸Ð»ÑŒÑ‚Ñ€ÑƒÐµÐ¼ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹, Ð¸ÑÐºÐ»ÑŽÑ‡Ð°Ñ Ñ‚Ðµ, Ñ‡Ñ‚Ð¾ Ð¸Ð¼ÐµÑŽÑ‚ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ None
        valid_context_params = [
            param for param in context_params 
            if param.value is not None and param.value.lower() not in ['null', 'none', '']
        ]
        
        if not valid_context_params:
            logger.info("ðŸ” ÐÐµÑ‚ Ð²Ð°Ð»Ð¸Ð´Ð½Ñ‹Ñ… Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ð´Ð»Ñ Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°")
            return None
        
        # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ Ð½Ð°Ð¹Ð´ÐµÐ½Ð½Ñ‹Ñ… Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð²
        found_param_names = {param.name for param in valid_context_params}
        
        logger.info(f"ðŸ” Ð’Ñ‹Ð±Ð¾Ñ€ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð° Ð¿Ð¾ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°Ð¼: {found_param_names}")
        
        best_tool = None
        best_score = 0
        
        for tool in available_tools:
            tool_name = tool.get('name', '')
            tool_description = tool.get('description', '')
            input_schema = tool.get('inputSchema', {})
            all_params = set(input_schema.get('properties', {}).keys())
            required_params = set(input_schema.get('required', []))
            
            # ÐŸÐ¾Ð´ÑÑ‡Ð¸Ñ‚Ñ‹Ð²Ð°ÐµÐ¼ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ ÑÐ¾Ð²Ð¿Ð°Ð´Ð°ÑŽÑ‰Ð¸Ñ… Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² (Ð²ÑÐµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹, Ð½Ðµ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ)
            matching_all_params = len(all_params & found_param_names)
            matching_required_params = len(required_params & found_param_names)
            
            # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²Ð¸Ðµ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ñ Ð·Ð°Ð´Ð°Ñ‡Ðµ
            description_match = self._check_description_match(tool_description, user_message)
            
            # Ð’Ñ‹Ñ‡Ð¸ÑÐ»ÑÐµÐ¼ Ð¾Ð±Ñ‰Ð¸Ð¹ Ð±Ð°Ð»Ð» Ñ Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚Ð¾Ð¼ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ñ… Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð²
            # ÐžÐ±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¿Ð¾Ð»ÑƒÑ‡Ð°ÑŽÑ‚ Ð±Ð¾Ð»ÑŒÑˆÐ¸Ð¹ Ð²ÐµÑ
            score = (matching_required_params * 3) + (matching_all_params * 1) + (1 if description_match else 0)
            
            logger.debug(f"ðŸ” [{tool_name}] ÐžÐ±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ: {matching_required_params}/{len(required_params)}, "
                        f"Ð’ÑÐµÐ³Ð¾: {matching_all_params}/{len(all_params)}, "
                        f"ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ: {description_match}, Ð‘Ð°Ð»Ð»: {score}")
            
            if score > best_score:
                best_score = score
                best_tool = tool
        
        return best_tool if best_score > 0 else None
    
    def _check_description_match(self, description: str, user_message: str) -> bool:
        """
        ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²Ð¸Ðµ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ñ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð° Ð·Ð°Ð´Ð°Ñ‡Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
        """
        if not description or not user_message:
            return False
        
        # ÐšÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ðµ ÑÐ»Ð¾Ð²Ð° Ð´Ð»Ñ ÑÐ¾Ð¿Ð¾ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð¸Ñ
        keywords_map = {
            'Ð¿Ð¾Ð¸ÑÐº': ['search', 'find', 'lookup', 'query'],
            'ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ðµ': ['create', 'add', 'new', 'make'],
            'Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ': ['update', 'modify', 'edit', 'change'],
            'ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ðµ': ['delete', 'remove', 'drop'],
            'Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ': ['get', 'fetch', 'retrieve', 'show'],
            'Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ': ['user', 'person', 'account'],
            'Ð¿Ñ€Ð¾ÐµÐºÑ‚': ['project', 'task', 'issue'],
            'Ñ„Ð°Ð¹Ð»': ['file', 'document', 'attachment']
        }
        
        user_lower = user_message.lower()
        desc_lower = description.lower()
        
        for ru_keyword, en_keywords in keywords_map.items():
            if ru_keyword in user_lower:
                if any(keyword in desc_lower for keyword in en_keywords):
                    return True
        
        return False
    
    async def _select_tool_with_llm(
        self, 
        user_message: str, 
        available_tools: List[Dict[str, Any]], 
        context_params: List[ContextParameter]
    ) -> Optional[Dict[str, Any]]:
        """
        Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ LLM Ð´Ð»Ñ Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°
        """
        try:
            # Ð¤Ð¾Ñ€Ð¼Ð¸Ñ€ÑƒÐµÐ¼ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾Ð± Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°Ñ…
            tools_info = []
            for tool in available_tools:
                tool_name = tool.get('name', '')
                tool_description = tool.get('description', '')
                required_params = tool.get('inputSchema', {}).get('properties', {}).get('required', [])
                params_list = ', '.join(required_params) if required_params else 'Ð½ÐµÑ‚ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð²'
                
                tools_info.append(f"- {tool_name}: {tool_description} (Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹: {params_list})")
            
            tools_text = "\n".join(tools_info)
            
            # Ð¤Ð¾Ñ€Ð¼Ð¸Ñ€ÑƒÐµÐ¼ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð´Ð»Ñ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ
            params_text = ""
            if context_params:
                params_list = [f"{p.name}={p.value}" for p in context_params]
                params_text = f"ÐÐ°Ð¹Ð´ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹: {', '.join(params_list)}"
            
            system_message = f"""Ð¢Ñ‹ - ÑÐºÑÐ¿ÐµÑ€Ñ‚ Ð¿Ð¾ Ð²Ñ‹Ð±Ð¾Ñ€Ñƒ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð². Ð’Ñ‹Ð±ÐµÑ€Ð¸ Ð»ÑƒÑ‡ÑˆÐ¸Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð´Ð»Ñ Ð·Ð°Ð´Ð°Ñ‡Ð¸ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ.

Ð”ÐžÐ¡Ð¢Ð£ÐŸÐÐ«Ð• Ð˜ÐÐ¡Ð¢Ð Ð£ÐœÐ•ÐÐ¢Ð«:
{tools_text}

{params_text}

Ð—ÐÐ”ÐÐ§Ð: Ð’Ñ‹Ð±ÐµÑ€Ð¸ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð»ÑƒÑ‡ÑˆÐµ Ð²ÑÐµÐ³Ð¾ Ð¿Ð¾Ð´Ñ…Ð¾Ð´Ð¸Ñ‚ Ð´Ð»Ñ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð·Ð°Ð´Ð°Ñ‡Ð¸ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ.

Ð¤ÐžÐ ÐœÐÐ¢ ÐžÐ¢Ð’Ð•Ð¢Ð (Ñ‚Ð¾Ð»ÑŒÐºÐ¾ JSON):
{{
    "selected_tool": "Ð¸Ð¼Ñ_Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°",
    "reason": "ÐºÑ€Ð°Ñ‚ÐºÐ¾Ðµ_Ð¾Ð±ÑŠÑÑÐ½ÐµÐ½Ð¸Ðµ"
}}

Ð’ÐÐ–ÐÐž: ÐžÑ‚Ð²ÐµÑ‡Ð°Ð¹ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð² JSON Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ðµ!"""

            messages = [
                {"role": "system", "content": system_message},
                {"role": "user", "content": user_message}
            ]
            
            response = await self.llm_client.llm_provider.generate_response(messages)
            
            # ÐŸÐ°Ñ€ÑÐ¸Ð¼ Ð¾Ñ‚Ð²ÐµÑ‚
            try:
                cleaned_response = response.strip()
                json_start = cleaned_response.find('{')
                json_end = cleaned_response.rfind('}') + 1
                
                if json_start != -1 and json_end > json_start:
                    json_str = cleaned_response[json_start:json_end]
                    selection_data = json.loads(json_str)
                    
                    selected_tool_name = selection_data.get('selected_tool', '')
                    
                    # ÐÐ°Ñ…Ð¾Ð´Ð¸Ð¼ Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚
                    for tool in available_tools:
                        if tool.get('name') == selected_tool_name:
                            logger.info(f"âœ… LLM Ð²Ñ‹Ð±Ñ€Ð°Ð» Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚: {selected_tool_name}")
                            return tool
                    
                    logger.warning(f"âš ï¸ LLM Ð²Ñ‹Ð±Ñ€Ð°Ð» Ð½ÐµÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚: {selected_tool_name}")
                    return None
                else:
                    logger.warning("âš ï¸ JSON Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½ Ð² Ð¾Ñ‚Ð²ÐµÑ‚Ðµ LLM Ð¿Ñ€Ð¸ Ð²Ñ‹Ð±Ð¾Ñ€Ðµ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°")
                    return None
                    
            except json.JSONDecodeError as e:
                logger.warning(f"âš ï¸ ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ñ€Ð°ÑÐ¿Ð°Ñ€ÑÐ¸Ñ‚ÑŒ Ð²Ñ‹Ð±Ð¾Ñ€ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°: {e}")
                return None
                
        except Exception as e:
            logger.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð° Ñ‡ÐµÑ€ÐµÐ· LLM: {e}")
            return None
    
    async def _execute_tool_with_fallback(
        self,
        tool: Dict[str, Any],
        context_params: List[ContextParameter],
        user_message: str,
        chat_history: List[Dict[str, Any]],
        user_context: Dict[str, Any]
    ) -> str:
        """
        Ð’Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÑ‚ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ñ Ð¸Ð½Ñ‚ÐµÐ»Ð»ÐµÐºÑ‚ÑƒÐ°Ð»ÑŒÐ½Ñ‹Ð¼ fallback
        
        Args:
            tool: Ð’Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚
            context_params: Ð˜Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹
            user_message: Ð¡Ð¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
            chat_history: Ð˜ÑÑ‚Ð¾Ñ€Ð¸Ñ Ñ‡Ð°Ñ‚Ð°
            user_context: ÐšÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
            
        Returns:
            Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ
        """
        try:
            # Ð¨Ð°Ð³ 1: ÐŸÐ¾Ð´Ð³Ð¾Ñ‚Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð´Ð»Ñ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°
            tool_params = await self._prepare_tool_parameters(tool, context_params, user_message)
            
            # Ð¨Ð°Ð³ 2: ÐŸÑ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð²Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚
            execution_result = await self._execute_tool(tool, tool_params)
            
            # Ð¨Ð°Ð³ 3: Ð•ÑÐ»Ð¸ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾, Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚
            if execution_result.status == ToolExecutionStatus.SUCCESS:
                return await self._format_tool_result(execution_result.result, tool)
            
            # Ð¨Ð°Ð³ 4: Ð•ÑÐ»Ð¸ Ð½ÑƒÐ¶ÐµÐ½ fallback, Ð¿Ñ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð½Ð°Ð¹Ñ‚Ð¸ Ð°Ð»ÑŒÑ‚ÐµÑ€Ð½Ð°Ñ‚Ð¸Ð²Ð½Ñ‹Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚
            if execution_result.status == ToolExecutionStatus.FALLBACK_NEEDED:
                return await self._handle_tool_fallback(
                    tool, execution_result, context_params, user_message, chat_history, user_context
                )
            
            # Ð¨Ð°Ð³ 5: Ð•ÑÐ»Ð¸ Ð½Ðµ Ñ…Ð²Ð°Ñ‚Ð°ÐµÑ‚ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð², Ð¿Ñ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð¸Ñ… Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ
            if execution_result.status == ToolExecutionStatus.MISSING_PARAMS:
                return await self._handle_missing_parameters(
                    tool, execution_result, context_params, user_message, chat_history, user_context
                )
            
            # Ð¨Ð°Ð³ 6: Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ð¾ÑˆÐ¸Ð±ÐºÑƒ
            return f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°: {execution_result.error}"
            
        except Exception as e:
            logger.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð° Ñ fallback: {e}")
            return f"Ð˜Ð·Ð²Ð¸Ð½Ð¸Ñ‚Ðµ, Ð¿Ñ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ð¸ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°: {str(e)}"
    
    async def _prepare_tool_parameters(
        self, 
        tool: Dict[str, Any], 
        context_params: List[ContextParameter], 
        user_message: str
    ) -> Dict[str, Any]:
        """
        ÐŸÐ¾Ð´Ð³Ð¾Ñ‚Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÑ‚ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð´Ð»Ñ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð° Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð°
        
        Args:
            tool: Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚
            context_params: Ð˜Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹
            user_message: Ð¡Ð¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
            
        Returns:
            ÐŸÐ¾Ð´Ð³Ð¾Ñ‚Ð¾Ð²Ð»ÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹
        """
        tool_params = {}
        input_schema = tool.get('inputSchema', {})
        all_params = set(input_schema.get('properties', {}).keys())
        required_params = set(input_schema.get('required', []))
        
        # Ð¤Ð¸Ð»ÑŒÑ‚Ñ€ÑƒÐµÐ¼ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹, Ð¸ÑÐºÐ»ÑŽÑ‡Ð°Ñ Ñ‚Ðµ, Ñ‡Ñ‚Ð¾ Ð¸Ð¼ÐµÑŽÑ‚ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ None
        valid_context_params = [
            param for param in context_params 
            if param.value is not None and param.value.lower() not in ['null', 'none', '']
        ]
        
        logger.info(f"ðŸ”§ ÐŸÐ¾Ð´Ð³Ð¾Ñ‚Ð¾Ð²ÐºÐ° Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ð´Ð»Ñ {tool.get('name', '')}: "
                   f"Ð²ÑÐµÐ³Ð¾ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² {len(all_params)}, Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ñ… {len(required_params)}, "
                   f"Ð²Ð°Ð»Ð¸Ð´Ð½Ñ‹Ñ… Ð¸Ð· ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð° {len(valid_context_params)}")
        
        # ÐœÐ°Ð¿Ð¿Ð¸Ð½Ð³ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ð¸Ð· ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð°
        param_mapping = {
            'project_id': ['project', 'project_id', 'project_key'],
            'task_id': ['task', 'task_id', 'issue', 'issue_id'],
            'username': ['user', 'username', 'assignee'],
            'keyword': ['query', 'search', 'keyword'],
            'file_path': ['path', 'file_path', 'file'],
            'commit_hash': ['commit', 'hash', 'commit_id']
        }
        
        # Ð—Ð°Ð¿Ð¾Ð»Ð½ÑÐµÐ¼ Ð’Ð¡Ð• Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¸Ð· ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð° (Ð½Ðµ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ)
        for param_name in all_params:
            best_param = None
            best_confidence = 0.0
            
            # Ð˜Ñ‰ÐµÐ¼ Ð¿Ð¾Ð´Ñ…Ð¾Ð´ÑÑ‰Ð¸Ð¹ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€ Ð² ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ðµ
            for context_param in valid_context_params:
                if context_param.name in param_mapping.get(param_name, [param_name]):
                    if context_param.confidence > best_confidence:
                        best_param = context_param
                        best_confidence = context_param.confidence
            
            if best_param and best_confidence > 0.5:
                tool_params[param_name] = best_param.value
                param_type = "Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹" if param_name in required_params else "Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹"
                logger.info(f"âœ… [{param_type}] ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€ '{param_name}' = '{best_param.value}' (confidence: {best_confidence})")
            elif param_name in required_params:
                # Ð•ÑÐ»Ð¸ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½, Ð¿Ñ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð¸Ð·Ð²Ð»ÐµÑ‡ÑŒ Ð¸Ð· ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ
                extracted_value = await self._extract_param_from_message(param_name, user_message)
                if extracted_value:
                    tool_params[param_name] = extracted_value
                    logger.info(f"âœ… [Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹] ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€ '{param_name}' = '{extracted_value}' Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½ Ð¸Ð· ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ")
                else:
                    logger.warning(f"âš ï¸ [Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹] ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€ '{param_name}' Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½ Ð¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½")
        
        logger.info(f"âœ… ÐŸÐ¾Ð´Ð³Ð¾Ñ‚Ð¾Ð²Ð»ÐµÐ½Ñ‹ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð´Ð»Ñ {tool.get('name')}: {tool_params}")
        return tool_params
    
    async def _extract_param_from_message(self, param_name: str, message: str) -> Optional[str]:
        """Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÑ‚ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€ Ð¸Ð· ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ"""
        # Ð˜ÑÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ ÐºÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ðµ ÑÐ»Ð¾Ð²Ð° Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ð¹ Ð¸Ð· Ð¿Ð¾Ð¸ÑÐºÐ°
        action_keywords = [
            'ÑÐ¾Ð·Ð´Ð°Ð¹', 'Ð½Ð°Ð¹Ð´Ð¸', 'Ð¿Ð¾ÐºÐ°Ð¶Ð¸', 'Ð¿Ð¾Ð»ÑƒÑ‡Ð¸', 'Ð¾Ð±Ð½Ð¾Ð²Ð¸', 'ÑƒÐ´Ð°Ð»Ð¸', 'Ð´Ð¾Ð±Ð°Ð²ÑŒ',
            'create', 'find', 'show', 'get', 'update', 'delete', 'add',
            'Ð¿Ð¾Ð¸ÑÐº', 'ÑÐ¿Ð¸ÑÐ¾Ðº', 'Ð´ÐµÑ‚Ð°Ð»Ð¸', 'Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ'
        ]
        
        # ÐŸÑ€Ð¾ÑÑ‚Ð°Ñ Ð»Ð¾Ð³Ð¸ÐºÐ° Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð¸Ñ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð²
        if param_name in ['project_id', 'project']:
            match = re.search(r'Ð¿Ñ€Ð¾ÐµÐºÑ‚[:\s]+([A-Z][A-Z0-9-]+)', message, re.IGNORECASE)
            if match and not any(keyword.lower() in match.group(1).lower() for keyword in action_keywords):
                return match.group(1)
        
        if param_name in ['task_id', 'task', 'issue']:
            match = re.search(r'(?:Ð·Ð°Ð´Ð°Ñ‡Ð°|task|issue)[:\s]+([A-Z][A-Z0-9-]+)', message, re.IGNORECASE)
            if match and not any(keyword.lower() in match.group(1).lower() for keyword in action_keywords):
                return match.group(1)
        
        if param_name in ['username', 'user']:
            match = re.search(r'(?:Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ|user)[:\s]+([a-zA-Z0-9_-]+)', message, re.IGNORECASE)
            if match and not any(keyword.lower() in match.group(1).lower() for keyword in action_keywords):
                return match.group(1)
        
        if param_name in ['keyword', 'query', 'search']:
            # Ð˜Ñ‰ÐµÐ¼ ÐºÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ðµ ÑÐ»Ð¾Ð²Ð° Ð¿Ð¾ÑÐ»Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ Ð¿Ð¾Ð¸ÑÐºÐ°
            match = re.search(r'(?:Ð½Ð°Ð¹Ð´Ð¸|Ð¿Ð¾Ð¸ÑÐº|search)[:\s]+([^\s]+)', message, re.IGNORECASE)
            if match and not any(keyword.lower() in match.group(1).lower() for keyword in action_keywords):
                return match.group(1)
        
        if param_name in ['file_path', 'path', 'file']:
            match = re.search(r'(?:Ñ„Ð°Ð¹Ð»|file)[:\s]+([^\s]+)', message, re.IGNORECASE)
            if match and not any(keyword.lower() in match.group(1).lower() for keyword in action_keywords):
                return match.group(1)
        
        return None
    
    async def _execute_tool(self, tool: Dict[str, Any], params: Dict[str, Any]) -> ToolExecutionResult:
        """
        Ð’Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÑ‚ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð¸ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚
        
        Args:
            tool: Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚
            params: ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹
            
        Returns:
            Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ
        """
        try:
            server_name = tool.get('server', 'unknown')
            tool_name = tool.get('name', '')
            
            # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ñ… Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð²
            required_params = tool.get('inputSchema', {}).get('properties', {}).get('required', [])
            missing_params = [param for param in required_params if param not in params]
            
            if missing_params:
                return ToolExecutionResult(
                    status=ToolExecutionStatus.MISSING_PARAMS,
                    missing_params=missing_params
                )
            
            # Ð’Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÐ¼ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚
            result = await self.mcp_client.call_tool(server_name, tool_name, params)
            
            if 'error' in result:
                # Ð•ÑÐ»Ð¸ Ð²Ð½ÐµÑˆÐ½Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ñ‹ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹, Ð¿Ñ€Ð¾Ð±ÑƒÐµÐ¼ Ð²ÑÑ‚Ñ€Ð¾ÐµÐ½Ð½Ñ‹Ðµ
                if 'Ð½Ðµ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½' in result['error']:
                    result = await self.mcp_client.call_tool_builtin(server_name, tool_name, params)
                
                if 'error' in result:
                    return ToolExecutionResult(
                        status=ToolExecutionStatus.TOOL_ERROR,
                        error=result['error']
                    )
            
            return ToolExecutionResult(
                status=ToolExecutionStatus.SUCCESS,
                result=result
            )
            
        except Exception as e:
            return ToolExecutionResult(
                status=ToolExecutionStatus.TOOL_ERROR,
                error=str(e)
            )
    
    async def _handle_tool_fallback(
        self,
        original_tool: Dict[str, Any],
        execution_result: ToolExecutionResult,
        context_params: List[ContextParameter],
        user_message: str,
        chat_history: List[Dict[str, Any]],
        user_context: Dict[str, Any]
    ) -> str:
        """
        ÐžÐ±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÑ‚ fallback Ð½Ð° Ð°Ð»ÑŒÑ‚ÐµÑ€Ð½Ð°Ñ‚Ð¸Ð²Ð½Ñ‹Ðµ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹
        
        Args:
            original_tool: ÐžÑ€Ð¸Ð³Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚
            execution_result: Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ
            context_params: ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð°
            user_message: Ð¡Ð¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
            chat_history: Ð˜ÑÑ‚Ð¾Ñ€Ð¸Ñ Ñ‡Ð°Ñ‚Ð°
            user_context: ÐšÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
            
        Returns:
            Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸
        """
        try:
            # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð²ÑÐµ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹
            available_tools = await self.mcp_client.get_all_tools()
            
            # Ð˜ÑÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ Ð¾Ñ€Ð¸Ð³Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚
            fallback_tools = [tool for tool in available_tools if tool.get('name') != original_tool.get('name')]
            
            if not fallback_tools:
                return "Ð˜Ð·Ð²Ð¸Ð½Ð¸Ñ‚Ðµ, Ð½Ðµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð½Ð°Ð¹Ñ‚Ð¸ Ð°Ð»ÑŒÑ‚ÐµÑ€Ð½Ð°Ñ‚Ð¸Ð²Ð½Ñ‹Ðµ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹ Ð´Ð»Ñ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð²Ð°ÑˆÐµÐ³Ð¾ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ°."
            
            # Ð’Ñ‹Ð±Ð¸Ñ€Ð°ÐµÐ¼ Ð»ÑƒÑ‡ÑˆÐ¸Ð¹ fallback Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚
            fallback_tool = await self._select_best_tool(user_message, fallback_tools, context_params)
            
            if not fallback_tool:
                return "Ð˜Ð·Ð²Ð¸Ð½Ð¸Ñ‚Ðµ, Ð½Ðµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð½Ð°Ð¹Ñ‚Ð¸ Ð¿Ð¾Ð´Ñ…Ð¾Ð´ÑÑ‰Ð¸Ð¹ Ð°Ð»ÑŒÑ‚ÐµÑ€Ð½Ð°Ñ‚Ð¸Ð²Ð½Ñ‹Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚."
            
            logger.info(f"ðŸ”„ Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ fallback Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚: {fallback_tool.get('name')}")
            
            # Ð’Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÐ¼ fallback Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚
            tool_params = await self._prepare_tool_parameters(fallback_tool, context_params, user_message)
            execution_result = await self._execute_tool(fallback_tool, tool_params)
            
            if execution_result.status == ToolExecutionStatus.SUCCESS:
                return await self._format_tool_result(execution_result.result, fallback_tool)
            else:
                return f"Fallback Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ñ‚Ð°ÐºÐ¶Ðµ Ð½Ðµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð²Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ: {execution_result.error}"
                
        except Exception as e:
            logger.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° fallback: {e}")
            return f"Ð˜Ð·Ð²Ð¸Ð½Ð¸Ñ‚Ðµ, Ð¿Ñ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ð¸ Ð°Ð»ÑŒÑ‚ÐµÑ€Ð½Ð°Ñ‚Ð¸Ð²Ð½Ð¾Ð³Ð¾ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°: {str(e)}"
    
    async def _handle_missing_parameters(
        self,
        tool: Dict[str, Any],
        execution_result: ToolExecutionResult,
        context_params: List[ContextParameter],
        user_message: str,
        chat_history: List[Dict[str, Any]],
        user_context: Dict[str, Any]
    ) -> str:
        """
        ÐžÐ±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÑ‚ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹
        
        Args:
            tool: Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚
            execution_result: Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ
            context_params: ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð°
            user_message: Ð¡Ð¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
            chat_history: Ð˜ÑÑ‚Ð¾Ñ€Ð¸Ñ Ñ‡Ð°Ñ‚Ð°
            user_context: ÐšÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
            
        Returns:
            Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸
        """
        try:
            missing_params = execution_result.missing_params
            
            # ÐŸÑ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð½ÐµÐ´Ð¾ÑÑ‚Ð°ÑŽÑ‰Ð¸Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ñ‡ÐµÑ€ÐµÐ· Ð´Ñ€ÑƒÐ³Ð¸Ðµ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹
            for param in missing_params:
                param_value = await self._get_parameter_via_tools(param, user_message, chat_history, user_context)
                if param_value:
                    # Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€ Ð² ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ð¸ Ð¿Ñ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð²Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ ÑÐ½Ð¾Ð²Ð°
                    context_params.append(ContextParameter(
                        name=param,
                        value=param_value,
                        source="tool_extraction",
                        confidence=0.9
                    ))
            
            # ÐŸÑ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð²Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ ÑÐ½Ð¾Ð²Ð° Ñ Ð½Ð¾Ð²Ñ‹Ð¼Ð¸ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°Ð¼Ð¸
            tool_params = await self._prepare_tool_parameters(tool, context_params, user_message)
            execution_result = await self._execute_tool(tool, tool_params)
            
            if execution_result.status == ToolExecutionStatus.SUCCESS:
                return await self._format_tool_result(execution_result.result, tool)
            else:
                return f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹: {', '.join(missing_params)}"
                
        except Exception as e:
            logger.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ñ… Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð²: {e}")
            return f"Ð˜Ð·Ð²Ð¸Ð½Ð¸Ñ‚Ðµ, Ð¿Ñ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ð¸ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð²: {str(e)}"
    
    async def _get_parameter_via_tools(
        self, 
        param_name: str, 
        user_message: str, 
        chat_history: List[Dict[str, Any]], 
        user_context: Dict[str, Any]
    ) -> Optional[str]:
        """
        ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÑ‚ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€ Ñ‡ÐµÑ€ÐµÐ· Ð´Ñ€ÑƒÐ³Ð¸Ðµ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹
        
        Args:
            param_name: ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°
            user_message: Ð¡Ð¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
            chat_history: Ð˜ÑÑ‚Ð¾Ñ€Ð¸Ñ Ñ‡Ð°Ñ‚Ð°
            user_context: ÐšÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
            
        Returns:
            Ð—Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð° Ð¸Ð»Ð¸ None
        """
        try:
            # Ð›Ð¾Ð³Ð¸ÐºÐ° Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ñ‡ÐµÑ€ÐµÐ· Ð´Ñ€ÑƒÐ³Ð¸Ðµ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹
            if param_name in ['project_id', 'project']:
                # ÐŸÑ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð½Ð°Ð¹Ñ‚Ð¸ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ñ‹ Ñ‡ÐµÑ€ÐµÐ· GitLab Ð¸Ð»Ð¸ Jira
                search_tools = await self.mcp_client.get_all_tools()
                for tool in search_tools:
                    if 'search' in tool.get('name', '').lower() or 'find' in tool.get('name', '').lower():
                        # Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÐ¼ ÐºÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ðµ ÑÐ»Ð¾Ð²Ð° Ð¸Ð· ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ
                        keywords = re.findall(r'\b\w+\b', user_message)
                        if keywords:
                            # ÐŸÑ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð²Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ Ð¿Ð¾Ð¸ÑÐº
                            try:
                                result = await self.mcp_client.call_tool(
                                    tool.get('server', ''),
                                    tool.get('name', ''),
                                    {'query': ' '.join(keywords[:3])}  # Ð‘ÐµÑ€ÐµÐ¼ Ð¿ÐµÑ€Ð²Ñ‹Ðµ 3 ÑÐ»Ð¾Ð²Ð°
                                )
                                if 'error' not in result and result.get('data'):
                                    # Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÐ¼ Ð¿ÐµÑ€Ð²Ñ‹Ð¹ Ð½Ð°Ð¹Ð´ÐµÐ½Ð½Ñ‹Ð¹ Ð¿Ñ€Ð¾ÐµÐºÑ‚
                                    projects = result.get('data', [])
                                    if projects and len(projects) > 0:
                                        return projects[0].get('key') or projects[0].get('name')
                            except Exception:
                                continue
            
            return None
            
        except Exception as e:
            logger.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð° {param_name}: {e}")
            return None
    
    async def _format_tool_result(self, result: Any, tool: Dict[str, Any]) -> str:
        """
        Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚Ð¸Ñ€ÑƒÐµÑ‚ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°
        
        Args:
            result: Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°
            tool: Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚
            
        Returns:
            ÐžÑ‚Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚
        """
        try:
            if isinstance(result, dict):
                if 'error' in result:
                    return f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð° {tool.get('name', '')}: {result['error']}"
                
                if 'data' in result:
                    data = result['data']
                    if isinstance(data, list):
                        if len(data) == 0:
                            return f"ÐŸÐ¾ Ð·Ð°Ð¿Ñ€Ð¾ÑÑƒ '{tool.get('name', '')}' Ð½Ð¸Ñ‡ÐµÐ³Ð¾ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾."
                        
                        # Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ ÑÐ¿Ð¸ÑÐ¾Ðº Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð²
                        formatted_items = []
                        for item in data[:5]:  # ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð¿ÐµÑ€Ð²Ñ‹Ðµ 5 ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²
                            if isinstance(item, dict):
                                # Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ð¾Ð±ÑŠÐµÐºÑ‚
                                item_str = []
                                for key, value in item.items():
                                    if key in ['title', 'name', 'summary', 'subject']:
                                        item_str.append(f"**{value}**")
                                    elif key in ['id', 'key', 'number']:
                                        item_str.append(f"ID: {value}")
                                    elif key in ['status', 'state']:
                                        item_str.append(f"Ð¡Ñ‚Ð°Ñ‚ÑƒÑ: {value}")
                                    elif key in ['assignee', 'author']:
                                        item_str.append(f"Ð˜ÑÐ¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒ: {value}")
                                
                                if item_str:
                                    formatted_items.append(" â€¢ ".join(item_str))
                                else:
                                    formatted_items.append(str(item))
                            else:
                                formatted_items.append(str(item))
                        
                        result_text = "\n".join(formatted_items)
                        if len(data) > 5:
                            result_text += f"\n\n... Ð¸ ÐµÑ‰Ðµ {len(data) - 5} ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²"
                        
                        return result_text
                    else:
                        return str(data)
                else:
                    return str(result)
            else:
                return str(result)
                
        except Exception as e:
            logger.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð°: {e}")
            return f"Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð° {tool.get('name', '')}: {str(result)}"
